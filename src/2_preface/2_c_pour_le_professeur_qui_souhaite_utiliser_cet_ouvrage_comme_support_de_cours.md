## 2-C - Pour le professeur qui souhaite utiliser cet ouvrage comme support de cours

Nous souhaitons avec ces notes ouvrir un maximum de portes. À notre
niveau d'études, il nous paraît important de montrer que la
programmation d'un ordinateur est un vaste univers de concepts et de
méthodes, dans lequel chacun peut trouver son domaine de prédilection.
Nous ne pensons pas que tous nos étudiants doivent apprendre exactement
les mêmes choses. Nous voudrions plutôt qu'ils arrivent à développer
chacun des compétences quelque peu différentes, qui leur permettent de
se valoriser à leurs propres yeux ainsi qu'à ceux de leurs condisciples,
et également d'apporter leur contribution spécifique lorsqu'on leur
proposera de collaborer à des travaux d'envergure.

De toute manière, notre préoccupation primordiale doit être d'arriver à
susciter l'intérêt, ce qui est loin d'être acquis d'avance pour un sujet
aussi ardu que la programmation d'un ordinateur. Nous ne voulons pas
feindre de croire que nos jeunes élèves vont se passionner d'emblée pour
la construction de beaux algorithmes. Nous sommes plutôt convaincus
qu'un certain intérêt ne pourra durablement s'installer qu'à partir du
moment où ils commenceront à réaliser qu'ils sont devenus capables de
développer un projet personnel original, dans une certaine autonomie.

Ce sont ces considérations qui nous ont amenés à développer une
structure de cours que certains trouveront peut-être un peu chaotique.
Nous commençons par une série de chapitres très courts, qui expliquent
sommairement ce qu'est l'activité de programmation et posent les
quelques bases indispensables à la réalisation de petits programmes.
Ceux-ci pourront faire appel très tôt à des bibliothèques d'objets
existants, tels ceux de l'interface graphique *tkinter* par exemple,
afin que ce concept d'objet devienne rapidement familier. Ils devront
être suffisamment attrayants pour que leurs auteurs aient le sentiment
d'avoir déjà acquis une certaine maîtrise. Nous souhaiterions en effet
que les élèves puissent déjà réaliser une petite application graphique
dès la fin de leur première année d'études.

Très concrètement, cela signifie que nous pensons pouvoir explorer les
huit premiers chapitres de ces notes durant la première année de cours.
Cela suppose que l'on aborde d'abord toute une série de concepts
importants (types de données, variables, instructions de contrôle du
flux, fonctions et boucles) d'une manière assez rapide, sans trop se
préoccuper de ce que chaque concept soit parfaitement compris avant de
passer au suivant, en essayant plutôt d'inculquer le goût de la
recherche personnelle et de l'expérimentation. Il sera souvent plus
efficace de ré-expliquer les notions et les mécanismes essentiels plus
tard, en situation et dans des contextes variés.

Dans notre esprit, c'est surtout en seconde année que l'on cherchera à
structurer les connaissances acquises, en les approfondissant. Les
algorithmes seront davantage décortiqués et commentés. Les projets,
cahiers des charges et méthodes d'analyse seront discutés en
concertation. On exigera la tenue régulière d'un cahier de notes et la
rédaction de rapports techniques pour certains travaux.

L'objectif ultime sera pour chaque élève de réaliser un projet de
programmation original d'une certaine importance. On s'efforcera donc de
boucler l'étude théorique des concepts essentiels suffisamment tôt dans
l'année scolaire, afin que chacun puisse disposer du temps nécessaire.

Il faut bien comprendre que les nombreuses informations fournies dans
ces notes concernant une série de domaines particuliers (gestion des
interfaces graphiques, des communications, des bases de données, etc.)
sont facultatives. Ce sont seulement une série de suggestions et de
repères que nous avons inclus pour aider les étudiants à choisir et à
commencer leur projet personnel de fin d'études. Nous ne cherchons en
aucune manière à former des spécialistes d'un certain langage ou d'un
certain domaine technique : nous voulons simplement donner un petit
aperçu des immenses possibilités qui s'offrent à celui qui se donne la
peine d'acquérir une compétence de programmeur.

